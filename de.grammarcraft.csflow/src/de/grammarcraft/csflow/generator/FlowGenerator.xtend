/*
 * generated by Xtext
 */
package de.grammarcraft.csflow.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import de.grammarcraft.csflow.flow.Model
import de.grammarcraft.csflow.flow.Flow
import de.grammarcraft.csflow.flow.LeftPort
import de.grammarcraft.csflow.flow.GlobalInputPort
import de.grammarcraft.csflow.flow.UnnamedSubFlowPort
import de.grammarcraft.csflow.flow.Port
import de.grammarcraft.csflow.flow.RightPort
import de.grammarcraft.csflow.flow.GlobalOutputPort
import de.grammarcraft.csflow.flow.EbcOperation
import de.grammarcraft.csflow.flow.MethodOperation
import de.grammarcraft.csflow.flow.Operation

class FlowGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val model = resource.contents.head as Model
		fsa.generateFile(model.name + ".cs", model.compile)
	}
	
	def compile(Model model) ''' 
			namespace «model.name» {
				static void Main(string[] args)
				{
					var config = new FlowRuntimeConfiguration();
					
					// registration of streams
					config.AddStreamsFrom(@"/
						«FOR functionUnit:model.functionUnits»
							«IF functionUnit instanceof Flow»
								«val flow = functionUnit as Flow»
								// «flow.name» flow definition comes here
								«flow.name»
								«FOR stream:flow.streams»
									«stream.leftPort.determinePortName»,«stream.rightPort.determinePortName»
								«ENDFOR»
							«ENDIF»
						«ENDFOR»
					");
					
					// registration of operations
					config
						«FOR functionUnit:model.functionUnits»
							«IF functionUnit instanceof Operation»
								«val operation = functionUnit as Operation»
								«operation.synthesizeOperationRegistration»
							«ENDIF»
						«ENDFOR»
				}
			}
	'''
	def synthesizeOperationRegistration(Operation operation) {
		switch operation {
			EbcOperation: operation.synthesizeEBCOperationRegistration
			MethodOperation: operation.synthesizeMethodOperationRegistration
			default: "unknown op type"
		}
	}
	
	
	
	def synthesizeEBCOperationRegistration(EbcOperation ebcOperation) {
		'''.addOperation("«ebcOperation.name»", new «ebcOperation.class_.reference»())'''
	}
	
	
	def synthesizeMethodOperationRegistration(MethodOperation methodOperation) {
		'''.addAction<int,int>("«methodOperation.name»", «methodOperation.class_.reference».«methodOperation.method.name»)'''	
	}
	
	def determinePortName(LeftPort leftPort) {
		switch leftPort {
			Port case leftPort.port!=null: '''«leftPort.functionUnit.name».«leftPort.port.name»'''
			Port: '''«leftPort.functionUnit.name»'''
			UnnamedSubFlowPort: "."
			GlobalInputPort: ".in"
		}
	}

	def determinePortName(RightPort rightPort) {
		switch rightPort {
			Port case rightPort.port!=null: '''«rightPort.functionUnit.name».«rightPort.port.name»'''
			Port: '''«rightPort.functionUnit.name»'''
			UnnamedSubFlowPort: "."
			GlobalOutputPort: ".out"
		}
	}

}
