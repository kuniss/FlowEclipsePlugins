/*
 * generated by Xtext
 */
package de.grammarcraft.csflow.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import de.grammarcraft.csflow.flow.Model
import de.grammarcraft.csflow.flow.Flow
import de.grammarcraft.csflow.flow.LeftPort
import de.grammarcraft.csflow.flow.GlobalInputPort
import de.grammarcraft.csflow.flow.UnnamedSubFlowPort
import de.grammarcraft.csflow.flow.Port
import de.grammarcraft.csflow.flow.RightPort
import de.grammarcraft.csflow.flow.GlobalOutputPort

class FlowGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val model = resource.contents.head as Model
		fsa.generateFile(model.name + ".cs", model.compile)
	}
	
	def compile(Model model) ''' 
			namespace «model.name» {
				static void Main(string[] args)
				{
					var config = new FlowRuntimeConfiguration();
					config.AddStreamsFrom(@"/
						«FOR functionUnit:model.functionUnits»
							«IF functionUnit instanceof Flow»
								«val flow = functionUnit as Flow»
								// «flow.name» flow definition comes here
								«flow.name»
								«FOR stream:flow.streams»
									«stream.leftPort.determinePortName»,«stream.rightPort.determinePortName»
								«ENDFOR»
							«ENDIF»
						«ENDFOR»
					");
				}
			}
	'''
	
	def determinePortName(LeftPort leftPort) {
		switch leftPort {
			Port case leftPort.port!=null: '''«leftPort.functionUnit.name».«leftPort.port.name»'''
			Port: '''«leftPort.functionUnit.name»'''
			UnnamedSubFlowPort: "."
			GlobalInputPort: ".in"
		}
	}

	def determinePortName(RightPort rightPort) {
		switch rightPort {
			Port case rightPort.port!=null: '''«rightPort.functionUnit.name».«rightPort.port.name»'''
			Port: '''«rightPort.functionUnit.name»'''
			UnnamedSubFlowPort: "."
			GlobalOutputPort: ".out"
		}
	}

}
